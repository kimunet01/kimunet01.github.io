---
title: "백준 1316"
date: 2026-02-23 00:15:00 +0900
categories: [Algorithm, PS] # [대분류, 소분류] 순서입니다.
tags: [C++]
---

❗ 백준 1316번 문제 : `그룹 단어 체커`  
```
그룹 단어란 단어에 존재하는 모든 문자에 대해서, 각 문자가 연속해서 나타나는 경우만을 말한다.
예를 들면, ccazzzzbb는 c, a, z, b가 모두 연속해서 나타나고,
kin도 k, i, n이 연속해서 나타나기 때문에 그룹 단어이지만,
aabbbccb는 b가 떨어져서 나타나기 때문에 그룹 단어가 아니다.

단어 N개를 입력으로 받아 그룹 단어의 개수를 출력하는 프로그램을 작성하시오.
```

💫 `접근 방법`
```
이전에 나왔던 단어가 연속되지 않고 떨어져서 또 나오게 된다면 그룹 단어가 아닌것으로 이해.

bool 형식을 사용해서 그룹 단어인지 체크하는 변수를 선언.
알파벳 수 만큼의 Array를 선언하여 알파벳의 등장 유무를 확인.
prev 변수를 만들어 이전에 나온 char를 저장.
만약 알파벳이 이미 등장을 했고, prev와 같지 않다면 그룹단어가 아님.
그룹단어가 맞다면 그룹 단어의 수에 +1 하는 방식.
```

⭕ `코드`
```c++
#include <iostream>
using namespace std;

int main() {
	int line;
	int num{ 0 };
	cin >> line;
	string s;
	for (int i = 0; i < line; ++i) {
		int check[26]{ };
		cin >> s;
		char prev = ' ';
		bool is_group = true;
		for (int k = 0; k < s.length(); ++k) {
			if (check[s[k] - 'a'] == 0) {
				check[s[k] - 'a']++;
				prev = s[k];
			}
			else if (prev == s[k]) {
				continue;
			}
			else if (prev != s[k]) {
				is_group = false;
			}
		}
		if (is_group) {
			num++;
		}
	}
	cout << num;
}
```

💭 `개선 방법`
```
위의 코드는 알파벳의 등장 유무를 확인하는 배열이 int형 배열임.
그런데 등장 유무만 확인하면 되기 때문에
bool형 배열을 사용해서 메모리를 아끼는 것이 좀 더 효율적으로 보임.

또한 그룹단어가 아닌것이 확인 되면 끝까지 반복문을 진행 할 필요가 없음.
```

💡 `개선 코드`
```c++
#include <iostream>
using namespace std;

int main() {
	int line;
	int num{ 0 };
	cin >> line;
	string s;
	for (int i = 0; i < line; ++i) {
		bool check[26] {false};
		cin >> s;
		char prev = ' ';
		bool is_group = true;
		for (int k = 0; k < s.length(); ++k) {
			if (!check[s[k] - 'a']) {
				check[s[k] - 'a'] = true;
				prev = s[k];
			}
			else if (prev == s[k]) {
				continue;
			}
			else if (prev != s[k]) {
				is_group = false;
				break;
			}
		}
		if (is_group) {
		    num++;
		}
	}
	cout << num;
}
```